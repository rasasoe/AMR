# AMR

# 3륜 옴니휠 서빙 로봇 제어 프로젝트



## 📖 1. 프로젝트 개요

이 프로젝트는 **Raspberry Pi Pico**를 메인 MCU로 사용하여 3륜 옴니휠 기반 로봇의 정밀 이동을 구현하는 것을 목표로 합니다. MicroPython을 사용하여 하드웨어를 직접 제어하며, 엔코더 피드백과 PID 제어(P-Control)를 통해 안정적인 구동 시스템을 개발합니다.

---

## ⚙️ 2. 하드웨어 구성

### 주요 부품 목록

| 부품 종류 | 모델명 / 사양 |
| :--- | :--- |
| **MCU** | Raspberry Pi Pico |
| **모터** | GM37B-3322E (DC 12V, 1:30, 11PPR) |
| **모터 드라이버** | L298N Dual H-Bridge |
| **옴니휠** | 60mm Omni Wheel |
| **전원** | 12V Battery (e.g., Li-Po) |

### 로봇 기구학 정보 (Kinematics)

* **구동 방식**: 3륜 옴니휠 (휠 각도: 90°, 210°, 330°)
* **로봇 중심-바퀴 거리**: **100 mm** (0.1 m)
* **휠 지름**: **60 mm** (0.06 m)

---

## 🔌 3. 핀 맵 (Pin Mapping)

| 기능 | 모터 1 (후방) | 모터 2 (우전방) | 모터 3 (좌전방) |
| :--- | :---: | :---: | :---: |
| **PWM (ENA)** | `GP2` | `GP8` | `GP12` |
| **IN1** | `GP0` | `GP6` | `GP10` |
| **IN2** | `GP1` | `GP7` | `GP11` |
| **엔코더 A** | `GP3` | `GP9` | `GP13` |

---

## 💡 4. 핵심 제어 로직

### P 제어 (Proportional Control)

교수님의 요구사항에 따라 PID 제어 중 **P(비례) 제어**만을 사용하여 각 휠의 RPM을 제어합니다. `OmniRobot.update()` 메서드 내에서 목표 RPM과 현재 RPM의 오차(Error)에 비례常数(`kp`)를 곱하여 모터 출력을 조절합니다.

### 엔코더 피드백 기반 이동 (Closed-loop Control)

기존의 시간 기반 이동 방식은 오차가 크기 때문에, 엔코더의 펄스 카운트를 직접 추적하여 목표 거리와 각도를 정밀하게 제어하는 **폐쇄 루프 방식**을 구현했습니다.

* `go_distance(distance_m)`: 목표 거리를 엔코더 틱으로 변환한 후, 실제 누적된 틱 수가 목표에 도달하면 정지합니다.
* `turn_angle(angle_deg)`: 목표 각도를 바퀴가 움직여야 할 거리(호의 길이)로 계산하고, 이를 다시 엔코더 틱으로 변환하여 실제 회전량을 추적합니다.

---

# 🤖 3륜 옴니휠 로봇 P제어 시스템

이 프로젝트는 Raspberry Pi Pico와 MicroPython을 사용하여 3륜 옴니휠 로봇의 속도를 제어하는 시스템입니다. 엔코더 피드백과 P제어(비례 제어)를 통해 로봇이 목표 속도를 유지하도록 합니다.

---

## ✅ 주요 특징

* **P제어 기반 속도 유지**: 엔코더 피드백을 통해 각 바퀴의 현재 RPM을 측정하고, 목표 RPM과의 오차를 줄여나가는 P제어 로직을 구현했습니다.
* **역기구학(Inverse Kinematics)**: 로봇 전체의 목표 움직임(속도, 방향, 회전)을 각 바퀴가 회전해야 할 RPM으로 변환합니다.
* **방향 추정 로직**: 단일 채널 엔코더의 한계를 극복하기 위해, 모터에 내린 PWM 명령의 부호(+/-)를 바탕으로 바퀴의 회전 방향을 추정합니다.
* **모듈화된 구조**: 하드웨어 제어(`Motor`, `Encoder`)와 로봇 전체 제어(`OmniRobot`)를 클래스로 분리하여 코드의 가독성과 재사용성을 높였습니다.

---

## 📂 파일 구조

* `📄 robot_controller.py`: `Motor`, `Encoder`, `OmniRobot` 클래스가 포함된 핵심 제어 파일입니다. 로봇의 모든 제어 로직이 여기에 있습니다.
* `🚀 main.py`: `OmniRobot` 객체를 생성하고, 원하는 움직임을 명령하여 테스트하는 실행 파일입니다.

---

## 🕹️ 사용 방법

1.  **동작 설정**: `main.py` 파일에서 `robot.move()` 함수의 인자를 수정하여 로봇의 움직임을 설정합니다.

    ```python
    # main.py

    # 예시 1: 정면으로 0.2 m/s 속도로 전진
    robot.move(speed=0.2, angle_deg=0)

    # 예시 2: 왼쪽으로 0.15 m/s 속도로 측면 이동
    robot.move(speed=0.15, angle_deg=90)
    
    # 예시 3: 초당 90도 속도로 제자리에서 시계 방향 회전
    robot.move(speed=0, angle_deg=0, angular_velocity_dps=90)
    ```

2.  **P 게인 튜닝**: 로봇의 반응이 너무 느리거나, 심하게 떨리는 경우 `robot_controller.py`의 `kp` 값을 조절해야 합니다.

    ```python
    # robot_controller.py / OmniRobot 클래스 내부

    # P 제어 게인 (핵심 튜닝 값)
    self.kp = 30000.0 # 이 값을 높이면 반응이 빨라지고, 낮추면 부드러워집니다.
    ```
    * **`kp` 값이 너무 낮으면**: 로봇이 목표 속도에 도달하지 못하고 힘이 부족한 것처럼 보입니다.
    * **`kp` 값이 너무 높으면**: 로봇이 목표 속도를 중심으로 심하게 떨거나(진동), 윙 소리가 커질 수 있습니다.

3.  **실행**: `main.py` 파일을 라즈베리 파이 피코에서 실행합니다. 터미널에 각 모터의 목표 RPM(T)과 현재 RPM(C)이 실시간으로 출력됩니다.

---

## 🔮 한계 및 개선 과제

* **정확한 위치 제어 부재**: 현재 코드는 **속도 제어**에 중점을 두고 있어, "정확히 50cm 이동"과 같은 **위치 제어**는 불가능합니다. 이를 위해서는 Odometry(위치 추정) 로직을 추가해야 합니다.
* **단일 채널 엔코더**: 방향 추정 방식은 오버슈트나 외부 힘에 의한 역회전을 감지하지 못해 오차가 누적될 수 있습니다. 듀얼 채널(A/B상) 엔코더를 사용하면 이 문제를 해결할 수 있습니다.
